#!/bin/sh
#
# LINBO busybox-based initramfs bootscript
# (C) 2013 by Steffen Hoenig <s.hoenig@openthinclient.com>
#	      Joern Frenzel <j.frenzel@openthinclient.com>
# LICENSE: GPL V3

# Its purpose:
# 1. Mounting a squashfs container over nfs
# 2. Unifying this ro conainter with ramdisk and file overlay
# 3. Hand over control to "real" sysv init.

# Preconditions:
# - Kernel contains all _needed_ nfs, ethernet, aufs modules

. /init_functions

TCOS="/tcos"
LINK="$TCOS/link"       # nfs             OTC-Server:/openthinclient # the initial one!
WRITE="$TCOS/write"     # for aufs to write this is just a folder inside the /
BASE="$TCOS/base"       # squashfs # via loopback sfs-file: /tcos/link/sfs/base.sfs
PACKAGE="$TCOS/package"
SHADOW="$TCOS/shadow"
CUSTOM="$LINK/custom"

# Some more default variables here.
# Values can be overwritten in kernel commandline - Key=Value
#
fglrx=false
nvidia=false
figlet=true
splashImage=openthinclient.ppm
glamor=false


## MAIN ####################################################

export PATH=/bin:/usr/bin:/sbin:/usr/sbin


echo "Loading, please wait..."

[ -d /dev ] || mkdir -m 0755 /dev
[ -d /root ] || mkdir -m 0700 /root
[ -d /sys ] || mkdir /sys
[ -d /proc ] || mkdir /proc
[ -d /tmp ] || mkdir /tmp
[ -d /run ] || mkdir /run

mkdir -p /var/lock
mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
mount -t proc -o nodev,noexec,nosuid proc /proc

# Note that this only becomes /dev on the real filesystem if udev's scripts
# are used; which they will be, but it's worth pointing out
tmpfs_size="10M"
if [ -e /etc/udev/udev.conf ]; then
        . /etc/udev/udev.conf
fi
if ! mount -t devtmpfs -o size=$tmpfs_size,mode=0755 udev /dev; then
        echo "W: devtmpfs not available, falling back to tmpfs for /dev"
        mount -t tmpfs -o size=$tmpfs_size,mode=0755 udev /dev
        [ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1 
        [ -e /dev/null ] || mknod /dev/null c 1 3 
fi
mkdir /dev/pts
mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
mount -t tmpfs -o "nosuid,size=20%,mode=0755" tmpfs /run
mkdir -m 0755 /run/initramfs

# create TCOS essential folders
for folder in $LINK $WRITE $BASE $PACKAGE $SHADOW $CUSTOM; do mkdir -p $folder ; done

# Get Key=Value pairs from kernel commandline and overwrite defaults.
read CMDLINE < /proc/cmdline
getbootparams

# Shut up or display figlet logo if not in quiet mode.
# Use "vga=791 console=tty2 quiet" as kernel paramter to get it absolutely quiet.
grep -vwq quiet /proc/cmdline 
if [ $? = 0 ]; then
    $figlet && (echo ${BLUE}; cat /lib/consus.figlet; echo ${NORMAL}; sleep 1)
fi

# This is going to be part of base 2.0-24
depmod -a
for m in $(detect_nic) aufs nfs squashfs loop;
do
     modprobe $m
done

ip addr add 127.0.0.1/8 dev lo
ip link set dev lo up

# support multiple networkcards
[ -z $nic ] && nic=0
DHCP=""

for i in $nic; do
    echo "${CRE}${BLUE}DHCP Broadcasting for IP address (${MAGENTA}eth$i${BLUE})... ${NORMAL}"
    ip link set dev eth$i up
    udhcpc -a -q -i eth$i -s /etc/udhcpc/default.script && DHCP="eth$i"
    [ -n "$DHCP" ] && break
    echo "${RED}No answer from network.${NORMAL}"
    debugshell
done

# NFS (or local link #future)
MOUNTED=""

[ -n $nfsroot ] && NFSD=$nfsroot

touch /etc/fstab
mount -t nfs -o nolock -o ro -o retrans=10 -o vers=2 "$NFSD" $LINK

if [ $? -eq 0 ]; then
  MOUNTED="true"
  echo "$NFSD mounted ${GREEN} successfully...${NORMAL}"
else
  echo "${RED} could not mount $NFSD - exiting. ${NORMAL}"
  debugshell
fi

###############################################################
# get the splashscreen running if some framebuffer is enabled
# 

[ -c /dev/fb0 ] || mknod /dev/fb0 c 29 0               # ensure framebuffer device exists
echo 0 > /sys/class/graphics/fbcon/cursor_blink        # prevent cursor blinking
grep -q "vga=" /proc/cmdline && fbsplash -silent -s /tcos/link/custom/splashscreens/${splashImage} 

# SFS
# base.sfs
#

TREE=""

# mount base and packages sfs files
[ -f "$LINK/sfs/base.sfs" ] || (echo "${RED} could not find $LINK/sfs/base.sfs - exiting. ${NORMAL}" && exit 1)
if mount -t squashfs -o loop,ro "$LINK/sfs/base.sfs" $BASE 2>/dev/null; then
    echo "base.sfs mounted...${GREEN}yes${NORMAL}"
    TREE="$BASE=ro"
else
    echo "base.sfs mounted...${RED}no${NORMAL}"
fi

# other SFS
# mount module sfs and packages sfs

echo "0" >/proc/sys/kernel/printk

mountsfs package

# AUFS
#

AUFS=""
mount -t tmpfs -o mode=0755 none $WRITE # links writing branch to ram!

# TREE has a leading colon ":" ! (DEPRECATED)
# :DEBUG:
#mkdir /tcos/write1
#mount -t nfs -o nolock -o ro -o retrans=10 -o vers=2 10.224.129.30:/home/root /tcos/write1
#ls -la /tcos/write1/

#mount -t aufs -o noplink,br=/tcos/write1=rw:${TREE} unionfs $SHADOW  && AUFS="true"
mount -t aufs -o noplink,br:${WRITE}=rw:${TREE} unionfs $SHADOW  && AUFS="true"


# LINKS
#

#PATH="$PATH:/busybox/bin:${SHADOW}/busybox/bin:${SHADOW}/bin:${SHADOW}/sbin:${SHADOW}/usr/bin"
#export PATH

# save resolv.conf
cp /etc/resolv.conf ${SHADOW}/etc/resolv.conf
[ -e /etc/hostname ] && cp /etc/hostname ${SHADOW}/etc/hostname

# enables additional packages (in  bz2, gz. tar, plain, format)
mountcustom $CUSTOM

# modify /etc/init.d/.depend.* with insserv
# enables custom LSB
#
for service in /tcos/package/*/etc/init.d/*; do
  servicefilename=$(basename $service);
  ${SHADOW}/sbin/insserv ${SHADOW}/etc/init.d/$servicefilename
done


# ToDo: Source the graphics card stuff out in a separate file.

# Check if acceleration glamor should be used.
# This does not work with proprietary drivers at the moment, but we don't check this here.
# It's the admins decision.
#
if $glamor ; then 
    echo "${GREEN}Enabling xorg acceleration glamor.${NORMAL}"
    echo -e 'Section "Device"\n\tIdentifier "My GPU"\n\tOption "AccelMethod" "glamor"\nEndSection' > ${SHADOW}/etc/X11/xorg.conf.d/21-glamor.conf
fi

# Check if fglrx drivers for radeon cards should be used.
# Prevent using fglrx in case of non existing AMD hardware.
# 
if $fglrx && $(lspci | grep -q AMD); then 
    echo "${GREEN}Switching client to use proprietary fglrx drivers.${NORMAL}"
    mkdir -p ${SHADOW}/etc/X11/xorg.conf.d &> /dev/null
    echo -e 'Section "Device"\n\tIdentifier "My GPU"\n\tDriver "fglrx"\nEndSection' > ${SHADOW}/etc/X11/xorg.conf.d/20-fglrx.conf
    # Xorg will load necesarry kernel modules itself. There is no need to do this by hand.
    update-alternatives --set glx /usr/lib/fglrx # will also do the blacklisting
else
    echo "blacklist fglrx" >> ${SHADOW}/etc/modprobe.d/tcos-blacklist.conf
fi


# Check if nvidia driver for nvidia cards should be used.
# Prevent using nvidia in case of non existing Nvidia hardware.
# 
if $nvidia && $(lspci | grep -q NVIDIA); then 
    echo "${GREEN}Switching client to use proprietary nvidia drivers.${NORMAL}"
    echo "blacklist nouveau" >> ${SHADOW}/etc/modprobe.d/tcos-blacklist.conf 
    mkdir -p ${SHADOW}/etc/X11/xorg.conf.d &> /dev/null

    # write xorg.conf  snippet
    echo -e 'Section "Device"\n\tIdentifier "My GPU"\n\tDriver "nvidia"\nEndSection' > ${SHADOW}/etc/X11/xorg.conf.d/20-nvidia.conf

    # todo: link libglx.so to the nvidia libglx.so.XXX.XX - we assume there is only one 
    nvidia_glx_so=$(grep -l nvidia ${SHADOW}/usr/lib/xorg/modules/extensions/libglx.* | tail -n 1)
    rm -f ${SHADOW}/usr/lib/xorg/modules/extensions/libglx.so
    ln -s  $nvidia_glx_so ${SHADOW}/usr/lib/xorg/modules/extensions/libglx.so
    
    #####################################################################################
    # Some workaround, because the nvidia module sometimes fails to initialize propperly.
    # But if it is loaded/initialized a second time, it works. Strange, but this is a fact.
    # Kick it!
    # 
    modprobe nvidia
    X :5 -novtswitch -configdir ${SHADOW}/etc/X11/xorg.conf.d &> /dev/null &
    sleep 10;
    kill -9 $!
    rmmod nvidia
    #
    # Xorg will load the module again itself.
    # End of workaround.
    #####################################################################################
    
else
    echo "blacklist nvidia" >> ${SHADOW}/etc/modprobe.d/tcos-blacklist.conf
fi

#######################################################
# Try to automatically use swap devices.

# mdev does not know about blockdevices, 
# this should become a device

# activate swap
# lsblk reads old MBR and new GPT tables
#
#if $autoswap ; then
#    lsblk -P -o NAME,FSTYPE 2> /dev/null | grep swap | while read line; do 
#	eval "$line" 
#	swapon /dev/${NAME} &> /dev/null
#	[ $? -eq 0 ] && echo -e "activate swap on ${NAME} \t ${GREEN}OK${NORMAL}"
#    done
#fi
mkdir -p ${SHADOW}/tcos/base
mkdir -p ${SHADOW}/tcos/package
mkdir -p ${SHADOW}/tcos/link
mkdir -p ${SHADOW}/tcos/write

mount --bind /tcos/package /tcos/package
mount --bind /tcos/base /tcos/base
mount -n -o move /tcos/package ${SHADOW}/tcos/package
mount -n -o move /tcos/base ${SHADOW}/tcos/base
mount -n -o move /tcos/link ${SHADOW}/tcos/link
mount -n -o move /tcos/write ${SHADOW}/tcos/write

#debugshell
mount -n -o move /sys ${SHADOW}/sys
mount -n -o move /dev ${SHADOW}/dev
mount -n -o move /proc ${SHADOW}/proc


exec switch_root ${SHADOW} /sbin/init "$@" </dev/console >/dev/console 2>&1


